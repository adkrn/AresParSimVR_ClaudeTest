# ARES í•˜ë“œì›¨ì–´-ì‹œë®¬ë ˆì´í„° ì—°ë™ êµ¬í˜„ ê°€ì´ë“œ

## ğŸ“Œ ê°œìš”
ì´ ë¬¸ì„œëŠ” ARES ë‚™í•˜ì‚° ì‹œë®¬ë ˆì´í„° í•˜ë“œì›¨ì–´ì™€ Unity VR ì‹œë®¬ë ˆì´ì…˜ ì†Œí”„íŠ¸ì›¨ì–´ ê°„ì˜ ì—°ë™ êµ¬í˜„ì„ ìœ„í•œ ìƒì„¸ ê°€ì´ë“œì…ë‹ˆë‹¤.

## ğŸ—ï¸ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  VR í—¤ë“œì…‹/     â”‚â”€â”€â”€â”€â–¶â”‚  Unity ì‹œë®¬ë ˆì´í„° â”‚â”€â”€â”€â”€â–¶â”‚ ARES Hardware   â”‚â”€â”€â”€â”€â–¶â”‚ ARES Motion  â”‚
â”‚  ì»¨íŠ¸ë¡¤ëŸ¬       â”‚â—€â”€â”€â”€â”€â”‚                  â”‚â—€â”€â”€â”€â”€â”‚    Service      â”‚â—€â”€â”€â”€â”€â”‚   Platform   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚                          â”‚
                               â–¼                          â–¼
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚   Network    â”‚           â”‚   DLL API   â”‚
                        â”‚    Sync      â”‚           â”‚  (COM Port) â”‚
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“‹ ëª©ì°¨
1. [ì‚¬ì „ ì¤€ë¹„ì‚¬í•­](#1-ì‚¬ì „-ì¤€ë¹„ì‚¬í•­)
2. [ì´ˆê¸° ì„¤ì • ë° ì—°ê²°](#2-ì´ˆê¸°-ì„¤ì •-ë°-ì—°ê²°)
3. [ì‹¤ì‹œê°„ ë°ì´í„° ë™ê¸°í™”](#3-ì‹¤ì‹œê°„-ë°ì´í„°-ë™ê¸°í™”)
4. [ê²Œì„ ë¡œì§ í†µí•©](#4-ê²Œì„-ë¡œì§-í†µí•©)
5. [ì–‘ë°©í–¥ ë™ê¸°í™”](#5-ì–‘ë°©í–¥-ë™ê¸°í™”)
6. [ì´ë²¤íŠ¸ ì²˜ë¦¬](#6-ì´ë²¤íŠ¸-ì²˜ë¦¬)
7. [ì—ëŸ¬ ì²˜ë¦¬ ë° ë³µêµ¬](#7-ì—ëŸ¬-ì²˜ë¦¬-ë°-ë³µêµ¬)
8. [ìµœì í™” ë° ì„±ëŠ¥](#8-ìµœì í™”-ë°-ì„±ëŠ¥)
9. [í…ŒìŠ¤íŠ¸ ë° ê²€ì¦](#9-í…ŒìŠ¤íŠ¸-ë°-ê²€ì¦)

---

## 1. ì‚¬ì „ ì¤€ë¹„ì‚¬í•­

### 1.1 í•˜ë“œì›¨ì–´ ìš”êµ¬ì‚¬í•­
- ARES ë‚™í•˜ì‚° ì‹œë®¬ë ˆì´í„° ëª¨ì…˜ í”Œë«í¼
- RS-232/USB ì‹œë¦¬ì–¼ í†µì‹  í¬íŠ¸
- Windows 10/11 (64-bit)
- Meta Quest 2/3/Pro VR í—¤ë“œì…‹

### 1.2 ì†Œí”„íŠ¸ì›¨ì–´ ìš”êµ¬ì‚¬í•­
- Unity 6.1 (2023.x)
- ARES SDK Ver 0205 ì´ìƒ
- ARESParaSimDllMotionExternC.dll
- Visual C++ 2015-2022 ì¬ë°°í¬ ê°€ëŠ¥ íŒ¨í‚¤ì§€

### 1.3 í”„ë¡œì íŠ¸ ì„¤ì •
```csharp
// Unity í”„ë¡œì íŠ¸ ì„¤ì •
Platform: Android (Meta Quest)
XR Plugin: Meta XR SDK v74.0.3
Rendering: Universal Render Pipeline (URP)
```

---

## 2. ì´ˆê¸° ì„¤ì • ë° ì—°ê²°

### 2.1 í•˜ë“œì›¨ì–´ ì´ˆê¸°í™” ì½”ë“œ

```csharp
public class AresHardwareService : MonoBehaviour
{
    [Header("Hardware Settings")]
    [SerializeField] private uint comPort = 0;     // COM1
    [SerializeField] private uint timeout = 1000;  // 1ì´ˆ
    
    private bool isConnected = false;
    private Thread communicationThread;
    
    public bool Initialize()
    {
        // 1. DLL ë¡œë“œ ë° í™˜ê²½ í™•ì¸
        Debug.Log($"[ARES] ì´ˆê¸°í™” ì‹œì‘ - COM{comPort + 1}");
        Debug.Log($"[ARES] í”Œë«í¼: {Application.platform}");
        Debug.Log($"[ARES] Unity ë²„ì „: {Application.unityVersion}");
        
        try
        {
            // 2. í•˜ë“œì›¨ì–´ ì—°ê²°
            isConnected = AresParachuteAPI.ARESParaSIM__Initial(comPort, timeout);
            
            if (isConnected)
            {
                Debug.Log($"[ARES] COM{comPort + 1} ì—°ê²° ì„±ê³µ");
                
                // 3. í•˜ë“œì›¨ì–´ ì¤‘ë¦½ ìœ„ì¹˜ë¡œ ë¦¬ì…‹
                ResetHardware();
                
                // 4. í†µì‹  ìŠ¤ë ˆë“œ ì‹œì‘ (10Hz)
                StartCommunicationThread();
                
                return true;
            }
            else
            {
                Debug.LogError($"[ARES] COM{comPort + 1} ì—°ê²° ì‹¤íŒ¨");
                return false;
            }
        }
        catch (DllNotFoundException e)
        {
            Debug.LogError($"[ARES] DLLì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {e.Message}");
            return false;
        }
    }
    
    private void ResetHardware()
    {
        var neutralData = new ARES_PARASIM_MOTION_EX_DATA();
        neutralData.Init(); // Roll=10000, Yaw=18000 (ì¤‘ì•™ê°’)
        
        ARES_PARASIM_FEEDBACK_EX_DATA feedback;
        AresParachuteAPI.ARESParaSIM__MotionControlEx(ref neutralData, out feedback);
        
        Debug.Log("[ARES] í•˜ë“œì›¨ì–´ ì¤‘ë¦½ ìœ„ì¹˜ ì„¤ì • ì™„ë£Œ");
    }
}
```

### 2.2 í†µì‹  ìŠ¤ë ˆë“œ êµ¬í˜„

```csharp
private void StartCommunicationThread()
{
    threadRunning = true;
    communicationThread = new Thread(CommunicationLoop)
    {
        IsBackground = true,
        Name = "ARES Communication Thread"
    };
    communicationThread.Start();
    Debug.Log("[ARES] í†µì‹  ìŠ¤ë ˆë“œ ì‹œì‘ (10Hz)");
}

private void CommunicationLoop()
{
    ARES_PARASIM_MOTION_EX_DATA localMotionData = new();
    localMotionData.Init();
    
    while (threadRunning)
    {
        try
        {
            // 1. Unity ë°ì´í„° ìˆ˜ì§‘
            lock (dataLock)
            {
                if (hasNewMotionData)
                {
                    localMotionData = ConvertToApiFormat(outgoingData);
                    hasNewMotionData = false;
                }
            }
            
            // 2. í•˜ë“œì›¨ì–´ì™€ í†µì‹ 
            ARES_PARASIM_FEEDBACK_EX_DATA feedbackData;
            bool success = AresParachuteAPI.ARESParaSIM__MotionControlEx(
                ref localMotionData, 
                out feedbackData
            );
            
            if (success)
            {
                // 3. í”¼ë“œë°± ì²˜ë¦¬
                ProcessFeedback(feedbackData);
            }
            
            Thread.Sleep(20); // 50Hz â†’ ì‹¤ì œ 10Hz
        }
        catch (Exception e)
        {
            Debug.LogError($"[ARES] í†µì‹  ì˜¤ë¥˜: {e.Message}");
        }
    }
}
```

---

## 3. ì‹¤ì‹œê°„ ë°ì´í„° ë™ê¸°í™”

### 3.1 ë°ì´í„° êµ¬ì¡°ì²´ ì •ì˜

```csharp
// SDK êµ¬ì¡°ì²´ (Ver 0205)
[StructLayout(LayoutKind.Sequential)]
public struct ARES_PARASIM_MOTION_EX_DATA
{
    public uint Roll;                // 0-20000 (ì¤‘ì‹¬ 10000)
    public uint RollSpeed;            // 0-6000 RPM
    public uint Yawing;               // 0-36000 (ì¤‘ì‹¬ 18000)
    public uint YawingSpeed;          // 0-6000 RPM
    public uint YawingMode;           // 0-5 (íšŒì „ ëª¨ë“œ)
    public uint LTRiserLineStrength;  // 0-100%
    public uint RTRiserLineStrength;  // 0-100%
    public uint Event;                // 0-5 (ì´ë²¤íŠ¸)
}

[StructLayout(LayoutKind.Sequential)]
public struct ARES_PARASIM_FEEDBACK_EX_DATA
{
    public uint RollPosition;              // 0-20000 (Ver 0205 ì¶”ê°€)
    public uint YawingPosition;            // 0-36000
    public uint LTRiserLineCurrentLength;  // 0-100%
    public uint LTRiserLineDetect;         // 0 or 1
    public uint RTRiserLineCurrentLength;  // 0-100%
    public uint RTRiserLineDetect;         // 0 or 1
}
```

### 3.2 ê°ë„ ë³€í™˜ ê³µì‹ ìƒì„¸ ì„¤ëª…

#### Roll ê°ë„ ë³€í™˜ ìˆ˜í•™ì  ìœ ë„

**Unity â†’ Hardware (Roll: -180Â°~+180Â° â†’ 0~20000)**

```
ëª©í‘œ: Unityì˜ Roll ê°ë„ë¥¼ í•˜ë“œì›¨ì–´ ê°’ìœ¼ë¡œ ë³€í™˜
Unity Range: -180Â° ~ +180Â° (ì´ 360Â°)
Hardware Range: 0 ~ 20000 (ì¤‘ì‹¬ê°’ 10000)

ìˆ˜í•™ì  ê´€ê³„ì‹:
1. ì¤‘ì‹¬ê°’ ë§¤í•‘: Unity 0Â° = Hardware 10000
2. ë²”ìœ„ ë§¤í•‘: Unity Â±180Â° = Hardware ë²”ìœ„ Â±10000

ë³€í™˜ ê³µì‹ ìœ ë„:
Unity -180Â° â†’ Hardware 0     (10000 - 10000)
Unity 0Â°     â†’ Hardware 10000 (10000 + 0)
Unity +180Â° â†’ Hardware 20000  (10000 + 10000)

ì¼ë°˜ì‹: Hardware_Value = 10000 + (Unity_Angle Ã— 10000 / 180)

ê²€ì¦:
Unity -180Â° â†’ 10000 + (-180 Ã— 10000/180) = 10000 - 10000 = 0 âœ“
Unity 0Â°     â†’ 10000 + (0 Ã— 10000/180) = 10000 âœ“
Unity +180Â° â†’ 10000 + (180 Ã— 10000/180) = 10000 + 10000 = 20000 âœ“
```

**Hardware â†’ Unity (Roll: 0~20000 â†’ -180Â°~+180Â°)**

```
ì—­ë³€í™˜ ê³µì‹ ìœ ë„:
Hardware 0     â†’ Unity -180Â°
Hardware 10000 â†’ Unity 0Â°
Hardware 20000 â†’ Unity +180Â°

Step 1: Hardware ê°’ì„ 0~1 ë²”ìœ„ë¡œ ì •ê·œí™”
normalized = Hardware_Value / 20000

Step 2: 0~1ì„ 0Â°~360Â° ë²”ìœ„ë¡œ ë³€í™˜
angle_360 = normalized Ã— 360Â°

Step 3: 0Â°~360Â°ë¥¼ -180Â°~+180Â° ë²”ìœ„ë¡œ ì¡°ì •
final_angle = angle_360 - 180Â°

ì¼ë°˜ì‹: Unity_Angle = (Hardware_Value / 20000 Ã— 360) - 180

ê²€ì¦:
Hardware 0     â†’ (0/20000 Ã— 360) - 180 = 0 - 180 = -180Â° âœ“
Hardware 10000 â†’ (10000/20000 Ã— 360) - 180 = 180 - 180 = 0Â° âœ“
Hardware 20000 â†’ (20000/20000 Ã— 360) - 180 = 360 - 180 = +180Â° âœ“
```

#### Yaw ê°ë„ ë³€í™˜ ìˆ˜í•™ì  ìœ ë„

**Unity â†’ Hardware (Yaw: 0Â°~360Â° â†’ 0~36000)**

```
ëª©í‘œ: Unityì˜ Yaw ê°ë„ë¥¼ í•˜ë“œì›¨ì–´ ê°’ìœ¼ë¡œ ë³€í™˜
Unity Range: 0Â° ~ 360Â°
Hardware Range: 0 ~ 36000

ìˆ˜í•™ì  ê´€ê³„ì‹:
ë¹„ìœ¨ = 36000 / 360 = 100
ì¦‰, 1Â° = 100 units

ë³€í™˜ ê³µì‹:
Hardware_Value = Unity_Angle Ã— 100

ê²€ì¦:
Unity 0Â°   â†’ 0 Ã— 100 = 0 âœ“
Unity 90Â°  â†’ 90 Ã— 100 = 9000 âœ“
Unity 180Â° â†’ 180 Ã— 100 = 18000 âœ“
Unity 270Â° â†’ 270 Ã— 100 = 27000 âœ“
Unity 360Â° â†’ 360 Ã— 100 = 36000 (â†’ 0ìœ¼ë¡œ ì²˜ë¦¬) âœ“
```

**Hardware â†’ Unity (Yaw: 0~36000 â†’ 0Â°~360Â°)**

```
ì—­ë³€í™˜ ê³µì‹:
Unity_Angle = Hardware_Value / 100

ê²€ì¦:
Hardware 0     â†’ 0 / 100 = 0Â° âœ“
Hardware 9000  â†’ 9000 / 100 = 90Â° âœ“
Hardware 18000 â†’ 18000 / 100 = 180Â° âœ“
Hardware 27000 â†’ 27000 / 100 = 270Â° âœ“
Hardware 36000 â†’ 36000 / 100 = 360Â° (â†’ 0Â°ë¡œ ì²˜ë¦¬) âœ“
```

### 3.3 Unity â†’ Hardware ë°ì´í„° ë³€í™˜ êµ¬í˜„

```csharp
private ARES_PARASIM_MOTION_EX_DATA ConvertToApiFormat(AresMotionData data)
{
    // ========== Roll ë³€í™˜: -180Â°~+180Â° â†’ 0~20000 ==========
    // Step 1: Unity ê°ë„ë¥¼ -180~+180 ë²”ìœ„ë¡œ ì •ê·œí™”
    float normalizedRoll = data.RollAngle;
    while (normalizedRoll > 180f) normalizedRoll -= 360f;
    while (normalizedRoll < -180f) normalizedRoll += 360f;
    
    // Step 2: ë³€í™˜ ê³µì‹ ì ìš©
    // Hardware_Value = 10000 + (Unity_Angle Ã— 10000 / 180)
    float rollValue = 10000f + (normalizedRoll * 10000f / 180f);
    
    // Step 3: ì•ˆì „ ë²”ìœ„ í´ë¨í•‘
    rollValue = Mathf.Clamp(rollValue, 0f, 20000f);
    
    // ========== Yaw ë³€í™˜: 0Â°~360Â° â†’ 0~36000 ==========
    // Step 1: Unity ê°ë„ë¥¼ 0~360 ë²”ìœ„ë¡œ ì •ê·œí™”
    float normalizedYaw = ((data.YawAngle % 360f) + 360f) % 360f;
    
    // Step 2: ë³€í™˜ ê³µì‹ ì ìš©
    // Hardware_Value = Unity_Angle Ã— 100
    uint yawingValue = (uint)(normalizedYaw * 100f);
    
    // Step 3: 360ë„ ê²½ê³„ ì²˜ë¦¬
    if (yawingValue >= 36000) yawingValue = 0;
    
    return new ARES_PARASIM_MOTION_EX_DATA
    {
        Roll = (uint)rollValue,
        Yawing = yawingValue,
        LTRiserLineStrength = (uint)(Mathf.Clamp01(data.LeftRiser) * 100f),
        RTRiserLineStrength = (uint)(Mathf.Clamp01(data.RightRiser) * 100f),
        RollSpeed = 3000,      // ê¸°ë³¸ ì†ë„
        YawingSpeed = 3000,    // ê¸°ë³¸ ì†ë„
        YawingMode = 0,        // Near ëª¨ë“œ
        Event = data.Event
    };
}
```

### 3.4 Hardware â†’ Unity ë°ì´í„° ë³€í™˜ êµ¬í˜„

```csharp
private AresFeedbackData ConvertFromApiFormat(ARES_PARASIM_FEEDBACK_EX_DATA data)
{
    return new AresFeedbackData
    {
        // ========== Roll ë³€í™˜: 0~20000 â†’ -180Â°~+180Â° ==========
        // ê³µì‹: Unity_Angle = (Hardware_Value / 20000 Ã— 360) - 180
        RollPosition = (data.RollPosition / 20000f * 360f) - 180f,
        
        // ========== Yaw ë³€í™˜: 0~36000 â†’ 0Â°~360Â° ==========
        // ê³µì‹: Unity_Angle = Hardware_Value / 100
        YawPosition = data.YawingPosition / 100f,
        
        // ë¼ì´ì € ê¸¸ì´: 0~100% (ë³€í™˜ ë¶ˆí•„ìš”)
        LeftRiserLength = data.LTRiserLineCurrentLength,
        RightRiserLength = data.RTRiserLineCurrentLength,
        
        // ë¼ì´ì € ê°ì§€ ì—¬ë¶€: 0/1 â†’ bool
        LeftRiserDetected = data.LTRiserLineDetect > 0,
        RightRiserDetected = data.RTRiserLineDetect > 0
    };
}
```

### 3.5 ë³€í™˜ ì˜ˆì‹œ ë° ê²€ì¦

#### Roll ë³€í™˜ ì˜ˆì‹œ

| Unity Roll | ê³„ì‚° ê³¼ì • | Hardware Value |
|------------|-----------|----------------|
| -180Â° | 10000 + (-180 Ã— 10000/180) = 10000 - 10000 | 0 |
| -90Â° | 10000 + (-90 Ã— 10000/180) = 10000 - 5000 | 5000 |
| 0Â° | 10000 + (0 Ã— 10000/180) = 10000 + 0 | 10000 |
| +90Â° | 10000 + (90 Ã— 10000/180) = 10000 + 5000 | 15000 |
| +180Â° | 10000 + (180 Ã— 10000/180) = 10000 + 10000 | 20000 |

#### Yaw ë³€í™˜ ì˜ˆì‹œ

| Unity Yaw | ê³„ì‚° ê³¼ì • | Hardware Value |
|-----------|-----------|----------------|
| 0Â° | 0 Ã— 100 | 0 |
| 45Â° | 45 Ã— 100 | 4500 |
| 90Â° | 90 Ã— 100 | 9000 |
| 180Â° | 180 Ã— 100 | 18000 |
| 270Â° | 270 Ã— 100 | 27000 |
| 360Â° | 360 Ã— 100 | 36000 â†’ 0 |

#### ë³€í™˜ ê²€ì¦ í…ŒìŠ¤íŠ¸ ì½”ë“œ

```csharp
[ContextMenu("Test Angle Conversions")]
private void TestAngleConversions()
{
    Debug.Log("===== ê°ë„ ë³€í™˜ í…ŒìŠ¤íŠ¸ =====");
    
    // Roll í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤
    float[] testRolls = { -180f, -90f, 0f, 90f, 180f };
    foreach (float roll in testRolls)
    {
        // Unity â†’ Hardware
        uint hardwareRoll = ConvertRollToHardware(roll);
        // Hardware â†’ Unity
        float unityRoll = ConvertRollToUnity(hardwareRoll);
        
        Debug.Log($"Roll: {roll}Â° â†’ HW:{hardwareRoll} â†’ Unity:{unityRoll}Â°");
        Debug.Assert(Mathf.Abs(roll - unityRoll) < 0.01f, 
            $"Roll ë³€í™˜ ì˜¤ë¥˜: {roll} != {unityRoll}");
    }
    
    // Yaw í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤
    float[] testYaws = { 0f, 90f, 180f, 270f, 360f };
    foreach (float yaw in testYaws)
    {
        // Unity â†’ Hardware
        uint hardwareYaw = ConvertYawToHardware(yaw);
        // Hardware â†’ Unity
        float unityYaw = ConvertYawToUnity(hardwareYaw);
        
        Debug.Log($"Yaw: {yaw}Â° â†’ HW:{hardwareYaw} â†’ Unity:{unityYaw}Â°");
        Debug.Assert(Mathf.Abs(yaw % 360f - unityYaw) < 0.01f, 
            $"Yaw ë³€í™˜ ì˜¤ë¥˜: {yaw} != {unityYaw}");
    }
    
    Debug.Log("===== ë³€í™˜ í…ŒìŠ¤íŠ¸ ì™„ë£Œ =====");
}

private uint ConvertRollToHardware(float unityAngle)
{
    // -180~+180 ë²”ìœ„ë¡œ ì •ê·œí™”
    float normalized = ((unityAngle % 360f) + 360f) % 360f;
    if (normalized > 180f) normalized -= 360f;
    
    // ë³€í™˜ ê³µì‹ ì ìš©
    return (uint)Mathf.Clamp(10000 + (normalized * 10000f / 180f), 0, 20000);
}

private float ConvertRollToUnity(uint hardwareValue)
{
    // ì—­ë³€í™˜ ê³µì‹ ì ìš©
    return (hardwareValue / 20000f * 360f) - 180f;
}

private uint ConvertYawToHardware(float unityAngle)
{
    // 0~360 ë²”ìœ„ë¡œ ì •ê·œí™”
    float normalized = ((unityAngle % 360f) + 360f) % 360f;
    
    // ë³€í™˜ ê³µì‹ ì ìš©
    uint value = (uint)(normalized * 100f);
    return value >= 36000 ? 0 : value;
}

private float ConvertYawToUnity(uint hardwareValue)
{
    // ì—­ë³€í™˜ ê³µì‹ ì ìš©
    return hardwareValue / 100f;
}
```

---

## ğŸ”„ ì–‘ë°©í–¥ í”¼ë“œë°± ë£¨í”„ (4ë‹¨ê³„ ì—°ë™ í”„ë¡œì„¸ìŠ¤)

### ì—°ë™ ê³¼ì • íë¦„ë„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          4ë‹¨ê³„ ì–‘ë°©í–¥ í”¼ë“œë°± ë£¨í”„                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  1ë‹¨ê³„: í•˜ë“œì›¨ì–´ â†’ Unity (ë¼ì´ì € ì…ë ¥)                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ ë¬¼ë¦¬ì  ë¼ì´ì €  â”‚â”€â”€â”€â”€â”€â”€â”€â–¶â”‚   FEEDBACK_DATA   â”‚â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ Unity ìˆ˜ì‹    â”‚     â”‚
â”‚  â”‚    ë‹¹ê¹€       â”‚        â”‚ LT/RTRiserLength â”‚        â”‚ leftPull     â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                                              â–¼              â”‚
â”‚                                                                             â”‚
â”‚  2ë‹¨ê³„: Unity â†’ í•˜ë“œì›¨ì–´ (íšŒì „ ëª…ë ¹)                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜â”‚â”€â”€â”€â”€â”€â”€â”€â–¶â”‚   MOTION_DATA    â”‚â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ í•˜ë“œì›¨ì–´ ëª…ë ¹ â”‚     â”‚
â”‚  â”‚ ApplyTurning â”‚        â”‚  Roll, Yawing    â”‚        â”‚   íšŒì „ ì‹œì‘   â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                                              â–¼              â”‚
â”‚                                                                             â”‚
â”‚  3ë‹¨ê³„: í•˜ë“œì›¨ì–´ â†’ Unity (ì‹¤ì œ ìœ„ì¹˜ í”¼ë“œë°±)                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ ë¬¼ë¦¬ì  íšŒì „   â”‚â”€â”€â”€â”€â”€â”€â”€â–¶â”‚   FEEDBACK_DATA   â”‚â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ Unity ìˆ˜ì‹    â”‚     â”‚
â”‚  â”‚   ìˆ˜í–‰ ì™„ë£Œ   â”‚        â”‚ Roll/YawPosition â”‚        â”‚ ìœ„ì¹˜ ë°ì´í„°   â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                                              â–¼              â”‚
â”‚                                                                             â”‚
â”‚  4ë‹¨ê³„: Unity í™”ë©´ ë™ê¸°í™”                                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ ìœ„ì¹˜ ë³´ì •     â”‚â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ Transform ì—…ë°ì´íŠ¸â”‚â”€â”€â”€â”€â”€â”€â”€â–¶â”‚  í™”ë©´ ê°±ì‹     â”‚     â”‚
â”‚  â”‚ProcessPosSyncâ”‚        â”‚ Rotation ì¡°ì •     â”‚        â”‚  ë™ê¸°í™” ì™„ë£Œ  â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ê° ë‹¨ê³„ë³„ ìƒì„¸ êµ¬í˜„

#### 1ë‹¨ê³„: í•˜ë“œì›¨ì–´ ë¼ì´ì € ì…ë ¥ ì²˜ë¦¬
```csharp
// AresHardwareServiceì—ì„œ í”¼ë“œë°± ìˆ˜ì‹ 
private void ProcessFeedback(ARES_PARASIM_FEEDBACK_EX_DATA feedbackData)
{
    var feedback = ConvertFromApiFormat(feedbackData);
    
    // ë¼ì´ì € ì…ë ¥ ë°ì´í„° (0~100%)
    // LTRiserLineCurrentLength: ì™¼ìª½ ë¼ì´ì € ë‹¹ê¹€ ì •ë„
    // RTRiserLineCurrentLength: ì˜¤ë¥¸ìª½ ë¼ì´ì € ë‹¹ê¹€ ì •ë„
    
    lock (dataLock)
    {
        incomingFeedback = feedback;
        hasNewFeedback = true;
    }
    
    // Unity ë©”ì¸ ìŠ¤ë ˆë“œë¡œ ì´ë²¤íŠ¸ ì „ë‹¬
    OnFeedbackReceived?.Invoke(feedback);
}
```

#### 2ë‹¨ê³„: Unityì—ì„œ í•˜ë“œì›¨ì–´ë¡œ íšŒì „ ëª…ë ¹ ì „ì†¡ (ê°œì„ ëœ ë²„ì „)
```csharp
// ParagliderControllerì—ì„œ ëª©í‘œ íšŒì „ê°’ ê³„ì‚° ë° ì „ì†¡
void CalculateAndSendTargetRotation()
{
    // ë¼ì´ì € ì…ë ¥ ê¸°ë°˜ ëª©í‘œ íšŒì „ ê³„ì‚°
    float turnInput = rightPull - leftPull;  // -1 ~ +1
    
    // ëª©í‘œ Yaw ê°ë„ ê³„ì‚° (ëˆ„ì )
    targetYaw += turnInput * maxYawSpeed * Time.fixedDeltaTime;
    targetYaw = Mathf.Repeat(targetYaw, 360f);  // 0~360 ë²”ìœ„ ìœ ì§€
    
    // ëª©í‘œ Roll ê°ë„ ê³„ì‚°
    float targetRoll = turnInput * maxRoll;  // -20Â° ~ +20Â°
    
    // í•˜ë“œì›¨ì–´ë¡œ ëª©í‘œ ìœ„ì¹˜ ì „ì†¡
    var motionData = new AresMotionData
    {
        YawAngle = targetYaw,        // ëª©í‘œ Yaw ê°ë„
        RollAngle = targetRoll,      // ëª©í‘œ Roll ê°ë„
        LeftRiser = leftPull,        // í˜„ì¬ ë¼ì´ì € ì…ë ¥
        RightRiser = rightPull,      // í˜„ì¬ ë¼ì´ì € ì…ë ¥
        Event = currentEvent
    };
    
    // í•˜ë“œì›¨ì–´ë¡œ ì „ì†¡ (Unity ìì²´ëŠ” íšŒì „í•˜ì§€ ì•ŠìŒ)
    aresService?.SendMotionData(motionData);
    
    // Unity Transformì€ ì—…ë°ì´íŠ¸í•˜ì§€ ì•ŠìŒ!
    // ì‹¤ì œ íšŒì „ì€ 4ë‹¨ê³„ì—ì„œ í•˜ë“œì›¨ì–´ í”¼ë“œë°±ì„ ë°›ì•„ì„œë§Œ ìˆ˜í–‰
}
```

#### 3ë‹¨ê³„: í•˜ë“œì›¨ì–´ ì‹¤ì œ ìœ„ì¹˜ í”¼ë“œë°±
```csharp
// í•˜ë“œì›¨ì–´ê°€ ë¬¼ë¦¬ì  íšŒì „ ìˆ˜í–‰ í›„ ì‹¤ì œ ìœ„ì¹˜ ë°˜í™˜
// ARES_PARASIM_FEEDBACK_EX_DATA êµ¬ì¡°ì²´:
// - RollPosition: ì‹¤ì œ Roll ìœ„ì¹˜ (0~20000)
// - YawingPosition: ì‹¤ì œ Yaw ìœ„ì¹˜ (0~36000)

private AresFeedbackData ConvertFromApiFormat(ARES_PARASIM_FEEDBACK_EX_DATA data)
{
    return new AresFeedbackData
    {
        // ì‹¤ì œ í•˜ë“œì›¨ì–´ ìœ„ì¹˜
        RollPosition = (data.RollPosition / 20000f * 360f) - 180f,
        YawPosition = data.YawingPosition / 100f,
        
        // ë¼ì´ì € ìƒíƒœ
        LeftRiserLength = data.LTRiserLineCurrentLength,
        RightRiserLength = data.RTRiserLineCurrentLength,
        LeftRiserDetected = data.LTRiserLineDetect > 0,
        RightRiserDetected = data.RTRiserLineDetect > 0
    };
}
```

#### 4ë‹¨ê³„: Unity í™”ë©´ì„ í•˜ë“œì›¨ì–´ í”¼ë“œë°±ìœ¼ë¡œë§Œ ì—…ë°ì´íŠ¸ (í•µì‹¬ ë³€ê²½!)
```csharp
private void HandleAresFeedback(AresFeedbackData feedback)
{
    // 1. ë¼ì´ì € ì…ë ¥ ì²˜ë¦¬ (1ë‹¨ê³„ ë°ì´í„°)
    if (feedback.LeftRiserLength >= 20f)
    {
        leftPull = feedback.LeftRiserLength / 100f;
        isInputRiserL = true;
    }
    else
    {
        leftPull = 0f;
        isInputRiserL = false;
    }
    
    if (feedback.RightRiserLength >= 20f)
    {
        rightPull = feedback.RightRiserLength / 100f;
        isInputRiserR = true;
    }
    else
    {
        rightPull = 0f;
        isInputRiserR = false;
    }
    
    // 2. í•˜ë“œì›¨ì–´ í”¼ë“œë°±ìœ¼ë¡œ Unity Transform ì§ì ‘ ì—…ë°ì´íŠ¸ (í•˜ë“œì›¨ì–´ ìš°ì„  ëª¨ë“œ)
    if (hardwarePriorityMode && _isPara)
    {
        UpdateTransformFromHardware(feedback);
    }
}

private void UpdateTransformFromHardware(AresFeedbackData feedback)
{
    // í•˜ë“œì›¨ì–´ì˜ ì‹¤ì œ ìœ„ì¹˜ë¥¼ Unityì— ì§ì ‘ ì ìš©
    float hardwareYaw = feedback.YawPosition;    // 0~360Â°
    float hardwareRoll = feedback.RollPosition;  // -180~+180Â°
    
    // ë¶€ë“œëŸ¬ìš´ ë³´ê°„ ì ìš© (ì„ íƒì )
    if (useSmoothInterpolation)
    {
        float currentYaw = transform.eulerAngles.y;
        float currentRoll = transform.eulerAngles.z;
        
        // Lerpë¡œ ë¶€ë“œëŸ½ê²Œ ì „í™˜
        hardwareYaw = Mathf.LerpAngle(currentYaw, hardwareYaw, 
                                      interpolationSpeed * Time.deltaTime);
        hardwareRoll = Mathf.LerpAngle(currentRoll, hardwareRoll, 
                                       interpolationSpeed * Time.deltaTime);
    }
    
    // Unity Transform ì—…ë°ì´íŠ¸ (í•˜ë“œì›¨ì–´ ìœ„ì¹˜ ê·¸ëŒ€ë¡œ ë°˜ì˜)
    transform.rotation = Quaternion.Euler(
        transform.eulerAngles.x,  // PitchëŠ” ìœ ì§€
        hardwareYaw,               // í•˜ë“œì›¨ì–´ Yaw
        hardwareRoll               // í•˜ë“œì›¨ì–´ Roll
    );
    
    // ë””ë²„ê·¸ ë¡œê·¸
    if (debugMode)
    {
        Debug.Log($"[HW Priority] Yaw: {hardwareYaw:F1}Â°, Roll: {hardwareRoll:F1}Â°");
    }
}
```

### í•˜ë“œì›¨ì–´ ìš°ì„  ëª¨ë“œ ì„¤ì •
```csharp
[Header("Hardware Priority Mode Settings")]
[SerializeField] private bool hardwarePriorityMode = true;    // í•˜ë“œì›¨ì–´ ìš°ì„  ëª¨ë“œ
[SerializeField] private bool useSmoothInterpolation = true;  // ë¶€ë“œëŸ¬ìš´ ì „í™˜
[SerializeField] private float interpolationSpeed = 10f;      // ë³´ê°„ ì†ë„
[SerializeField] private bool debugMode = false;              // ë””ë²„ê·¸ ë¡œê·¸

// ëª©í‘œ ê°ë„ ì¶”ì  ë³€ìˆ˜
private float targetYaw = 0f;
private float targetRoll = 0f;
```

### Unity ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ ë¹„í™œì„±í™” (í•˜ë“œì›¨ì–´ ìš°ì„  ëª¨ë“œ)
```csharp
void FixedUpdate()
{
    if (!isJumpStart) return;
    
    if (hardwarePriorityMode && aresService?.IsConnected == true)
    {
        // í•˜ë“œì›¨ì–´ ìš°ì„  ëª¨ë“œ: Unity ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ ë¹„í™œì„±í™”
        // ApplyTurning() í˜¸ì¶œí•˜ì§€ ì•ŠìŒ!
        
        // ëª©í‘œ ìœ„ì¹˜ë§Œ ê³„ì‚°í•˜ì—¬ í•˜ë“œì›¨ì–´ë¡œ ì „ì†¡
        CalculateAndSendTargetRotation();
        
        // ì†ë„ ì œì–´ëŠ” ìœ ì§€ (ì „ì§„/í•˜ê°•)
        if (_isPara)
        {
            RegulateForwardSpeed();
            RegulateSinkRate();
        }
    }
    else
    {
        // í•˜ë“œì›¨ì–´ ì—†ì„ ë•Œ: ê¸°ì¡´ Unity ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ ì‚¬ìš©
        UpdateControlInputs();
        
        if (_isPara)
        {
            RiserDamping();
            RegulateForwardSpeed();
            RegulateSinkRate();
            ApplyTurning();  // Unity ìì²´ íšŒì „
            ApplyWindZoneForce();
        }
    }
}
```

### ê°œì„ ëœ íƒ€ì´ë° ë‹¤ì´ì–´ê·¸ë¨ (í•˜ë“œì›¨ì–´ ìš°ì„  ëª¨ë“œ)
```
ì‹œê°„ â†’
T0: ì‚¬ìš©ìê°€ ì™¼ìª½ ë¼ì´ì € 50% ë‹¹ê¹€
T1: [10ms] í•˜ë“œì›¨ì–´ê°€ ë¼ì´ì € ì…ë ¥ ê°ì§€
T2: [20ms] Unityê°€ FEEDBACK_DATA ìˆ˜ì‹  (leftPull = 0.5)
T3: [30ms] Unityê°€ ëª©í‘œ Yaw ê³„ì‚° (targetYaw += íšŒì „ì†ë„)
T4: [40ms] í•˜ë“œì›¨ì–´ë¡œ MOTION_DATA ì „ì†¡ (ëª©í‘œ ìœ„ì¹˜)
T5: [50ms] í•˜ë“œì›¨ì–´ ë¬¼ë¦¬ì  íšŒì „ ì‹œì‘
T6: [70ms] í•˜ë“œì›¨ì–´ íšŒì „ ì§„í–‰ ì¤‘, ì¤‘ê°„ ìœ„ì¹˜ í”¼ë“œë°±
T7: [80ms] Unityê°€ í•˜ë“œì›¨ì–´ ìœ„ì¹˜ë¡œ Transform ì—…ë°ì´íŠ¸
T8: [100ms] í•˜ë“œì›¨ì–´ ëª©í‘œ ìœ„ì¹˜ ë„ë‹¬
T9: [110ms] Unity í™”ë©´ = í•˜ë“œì›¨ì–´ ì‹¤ì œ ìœ„ì¹˜ (ì™„ì „ ë™ê¸°í™”)
```

### ë™ì‘ ëª¨ë“œ ë¹„êµ

| í•­ëª© | ê¸°ì¡´ ëª¨ë“œ (Unity ìš°ì„ ) | ê°œì„  ëª¨ë“œ (í•˜ë“œì›¨ì–´ ìš°ì„ ) |
|------|----------------------|------------------------|
| Unity ë¬¼ë¦¬ | rb.AddTorque() ì‚¬ìš© | ë¹„í™œì„±í™” |
| íšŒì „ ì£¼ì²´ | Unityê°€ ë¨¼ì € íšŒì „ | í•˜ë“œì›¨ì–´ë§Œ íšŒì „ |
| Transform ì—…ë°ì´íŠ¸ | ì¦‰ì‹œ (ë¬¼ë¦¬ ì—”ì§„) | í•˜ë“œì›¨ì–´ í”¼ë“œë°± ëŒ€ê¸° |
| ì§€ì—° ì‹œê°„ | ë‚®ìŒ (ì¦‰ì‹œ ë°˜ì‘) | ì¤‘ê°„ (í”¼ë“œë°± ëŒ€ê¸°) |
| ë™ê¸°í™” ì •í™•ë„ | ì˜¤ì°¨ ë°œìƒ ê°€ëŠ¥ | ì™„ë²½í•œ ë™ê¸°í™” |
| ì‹œê°ì  ë¶€ë“œëŸ¬ì›€ | ë§¤ìš° ë¶€ë“œëŸ¬ì›€ | ë³´ê°„ í•„ìš” |

---

## ğŸ“Š ë¼ì´ì € ì…ë ¥ â†’ íšŒì „ê°’ ê³„ì‚° ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ ìƒì„¸ ë¶„ì„

### ê°œìš”
íŒ¨ëŸ¬ê¸€ë¼ì´ë”ì˜ ë¼ì´ì €(ì¡°ì¢…ì¤„) ë‹¹ê¹€ì´ ì–´ë–»ê²Œ íšŒì „ ì›€ì§ì„ìœ¼ë¡œ ë³€í™˜ë˜ëŠ”ì§€ ë¬¼ë¦¬ ì—”ì§„ ê¸°ë°˜ìœ¼ë¡œ ë¶„ì„í•©ë‹ˆë‹¤.

### 1. ë¼ì´ì € ì…ë ¥ ì²˜ë¦¬ ë‹¨ê³„

#### 1.1 ì…ë ¥ê°’ ë²”ìœ„ ë° ì˜ë¯¸
```csharp
[Range(0f, 1f)] private float leftPull = 0f;   // ì™¼ìª½ ë¼ì´ì € (0=ì•ˆë‹¹ê¹€, 1=ìµœëŒ€)
[Range(0f, 1f)] private float rightPull = 0f;  // ì˜¤ë¥¸ìª½ ë¼ì´ì € (0=ì•ˆë‹¹ê¹€, 1=ìµœëŒ€)

// ì…ë ¥ ì°¨ì´ ê³„ì‚°
float turnInput = rightPull - leftPull;  // -1 ~ +1 ë²”ìœ„
// ìŒìˆ˜: ì™¼ìª½ íšŒì „, ì–‘ìˆ˜: ì˜¤ë¥¸ìª½ íšŒì „, 0: ì§ì§„
```

#### 1.2 ë¸Œë ˆì´í¬ ëŒí•‘ íš¨ê³¼ (ì–‘ìª½ ë™ì‹œ ë‹¹ê¹€)
```csharp
void RiserDamping()
{
    // ì¢Œìš° ë¼ì´ì € ë‹¹ê¹€ ì°¨ì´ ê³„ì‚° (0~1)
    float brakeInputDiffer = 1f - Mathf.Abs(leftPull - rightPull);
    
    // ì–‘ìª½ì„ ë™ì‹œì— ë‹¹ê¸¸ìˆ˜ë¡ ì¦ê°€í•˜ëŠ” ë¸Œë ˆì´í¬ íš¨ê³¼
    float brakeInputMultiplier = brakeInputDiffer * (leftPull * rightPull);
    
    // ìµœì¢… ë¸Œë ˆì´í¬ ë°°ìˆ˜ (1=ë¸Œë ˆì´í¬ ì—†ìŒ, 0=ìµœëŒ€ ë¸Œë ˆì´í¬)
    brakeMultiplier = 1f - brakeInputMultiplier;
}
```

**ë¸Œë ˆì´í¬ íš¨ê³¼ ë¶„ì„:**
| ì™¼ìª½ | ì˜¤ë¥¸ìª½ | ì°¨ì´ | ë¸Œë ˆì´í¬ íš¨ê³¼ | ê²°ê³¼ |
|------|--------|------|--------------|------|
| 0% | 0% | 0 | 0% | ì •ìƒ ì†ë„ |
| 50% | 50% | 0 | 25% | ì†ë„ 75%ë¡œ ê°ì†Œ |
| 100% | 100% | 0 | 100% | ì™„ì „ ì •ì§€ |
| 100% | 0% | 1 | 0% | ì •ìƒ ì†ë„ (ì¢ŒíšŒì „) |
| 70% | 30% | 0.4 | 12.6% | ì•½ê°„ ê°ì† (ì¢ŒíšŒì „) |

### 2. Yaw íšŒì „ ê³„ì‚° (ì¢Œìš° íšŒì „)

#### 2.1 ëª©í‘œ íšŒì „ ì†ë„ ê³„ì‚°
```csharp
// ë¬¼ë¦¬ íŒŒë¼ë¯¸í„°
[SerializeField] private float maxYawSpeed = 4f;         // ìµœëŒ€ íšŒì „ ì†ë„ (rad/s)
[SerializeField] private float yawControlStrength = 5f;  // P ê²Œì¸ (ì¶”ì¢… ê°•ë„)
[SerializeField] private float yawDamping = 3f;          // D ê²Œì¸ (ê°ì‡ )

void ApplyTurning()
{
    // Step 1: ì…ë ¥ìœ¼ë¡œë¶€í„° ëª©í‘œ íšŒì „ ì†ë„ ê³„ì‚°
    float turnInput = rightPull - leftPull;  // -1 ~ +1
    float targetYawSpeed = turnInput * maxYawSpeed;  // -4 ~ +4 rad/s
    
    // Step 2: í˜„ì¬ íšŒì „ ì†ë„ ì¸¡ì •
    float currentYawSpeed = rb.angularVelocity.y;
    
    // Step 3: PD ì œì–´ê¸°ë¡œ í† í¬ ê³„ì‚°
    float yawError = targetYawSpeed - currentYawSpeed;
    float yawCorrection = (yawError * yawControlStrength)     // Pí•­: ì˜¤ì°¨ì— ë¹„ë¡€
                        - (currentYawSpeed * yawDamping);      // Dí•­: ì†ë„ì— ë°˜ë¹„ë¡€ (ê°ì‡ )
    
    // Step 4: í† í¬ ì ìš©
    rb.AddTorque(Vector3.up * yawCorrection, ForceMode.Force);
}
```

#### 2.2 Yaw í† í¬ ê³„ì‚° ê³µì‹
```
í† í¬ = Pí•­ - Dí•­
     = (ëª©í‘œì†ë„ - í˜„ì¬ì†ë„) Ã— Pê²Œì¸ - í˜„ì¬ì†ë„ Ã— Dê²Œì¸
     
ì˜ˆì‹œ: ì˜¤ë¥¸ìª½ 50% ë‹¹ê¹€
- turnInput = 0.5 - 0 = 0.5
- targetYawSpeed = 0.5 Ã— 4 = 2 rad/s (ì•½ 114Â°/s)
- í˜„ì¬ì†ë„ = 0 rad/s ê°€ì •
- yawError = 2 - 0 = 2
- yawCorrection = 2 Ã— 5 - 0 Ã— 3 = 10 NÂ·m
```

### 3. Roll íšŒì „ ê³„ì‚° (ì¢Œìš° ê¸°ìš¸ê¸°)

#### 3.1 Rollê³¼ Yaw ì—°ë™
```csharp
// Rollì€ Yaw í† í¬ì— ë¹„ë¡€í•˜ì—¬ ìë™ ìƒì„± (ì‹¤ì œ íŒ¨ëŸ¬ê¸€ë¼ì´ë” ë¬¼ë¦¬)
float rollTorque = 0.3f * yawCorrection;  // Yaw í† í¬ì˜ 30%
rb.AddTorque(pasimPlayer.forward * -rollTorque, ForceMode.Force);
```

#### 3.2 Roll ì œí•œ ë° ë³µì›
```csharp
[SerializeField] private float maxRoll = 20f;  // ìµœëŒ€ ê¸°ìš¸ê¸° ê°ë„

// í˜„ì¬ Roll ê°ë„ ê³„ì‚° (-180 ~ +180)
float localZRoll = pasimPlayer.localEulerAngles.z;
if (localZRoll > 180f) localZRoll -= 360f;

// Roll ì œí•œ (maxRoll ì´ˆê³¼ì‹œ ë³µì›ë ¥ ì ìš©)
if (localZRoll > maxRoll)
    rb.AddTorque(pasimPlayer.forward * -(localZRoll - maxRoll) * 2f, ForceMode.Force);
else if (localZRoll < -maxRoll)
    rb.AddTorque(pasimPlayer.forward * -(localZRoll + maxRoll) * 2f, ForceMode.Force);

// ë¼ì´ì € ì…ë ¥ì´ ì—†ì„ ë•Œ ìë™ ìˆ˜í‰ ë³µì›
if (!isInputRiser)
{
    float autoLevelTorque = (-localZRoll * selfLevelStrengthRoll)      // Pí•­
                           - (angleVelo.z * selfLevelDampingRoll);      // Dí•­
    rb.AddTorque(pasimPlayer.forward * autoLevelTorque, ForceMode.Force);
}
```

### 4. Pitch ì œì–´ (ì•ë’¤ ê¸°ìš¸ê¸°)

#### 4.1 Pitch ì œí•œ ë° ë³µì›
```csharp
[SerializeField] private float maxPitch = 10f;  // ìµœëŒ€ í”¼ì¹˜ ê°ë„

// í˜„ì¬ Pitch ê°ë„ ê³„ì‚°
float pitch = pasimPlayer.localEulerAngles.x;
if (pitch > 180f) pitch -= 360f;

// Pitch ì œí•œ
if (pitch > maxPitch)
    rb.AddTorque(pasimPlayer.right * -(pitch - maxPitch) * 2f, ForceMode.Force);
else if (pitch < -maxPitch)
    rb.AddTorque(pasimPlayer.right * -(pitch + maxPitch) * 2f, ForceMode.Force);

// ë¼ì´ì € ì…ë ¥ì´ ì—†ì„ ë•Œ ìë™ ë³µì›
if (!isInputRiser && pitch != 0f)
{
    float autoPitchTorque = (-pitch * selfLevelStrengthPitch)
                          - (angleVelo.x * selfLevelDampingPitch);
    rb.AddTorque(pasimPlayer.right * autoPitchTorque, ForceMode.Force);
}
```

### 5. ì†ë„ ì œì•½ ì¡°ê±´

#### 5.1 ì „ì§„ ì†ë„ ì œì–´
```csharp
void RegulateForwardSpeed()
{
    // ì „ë°© ë²¡í„° ì¶”ì¶œ
    Vector3 fwdDir = pasimPlayer.forward;
    fwdDir.y = 0f;
    fwdDir.Normalize();
    
    // ì‹¤ì œ ì „ì§„ ì†ë„ ê³„ì‚°
    float fwd = Vector3.Dot(rb.linearVelocity, fwdDir);
    
    // ëª©í‘œ ì†ë„ ì¶”ì¢… (ë¸Œë ˆì´í¬ íš¨ê³¼ ì ìš©)
    float cmd = (targetForwardSpeed * fwdSpeedGain - fwd) * brakeMultiplier;
    rb.AddForce(fwdDir * cmd, ForceMode.Acceleration);
}
```

#### 5.2 íšŒì „ ê°€ëŠ¥ ì¡°ê±´
```csharp
// ì „ì§„ ì†ë„ê°€ 2m/s ë¯¸ë§Œì´ë©´ íšŒì „ ë¶ˆê°€
float horizontalSpeed = new Vector3(lineVelo.x, 0, lineVelo.z).magnitude;
if (horizontalSpeed < 2f) return;  // íšŒì „ í† í¬ ì°¨ë‹¨
```

### 6. ì‹¤ì œ ì ìš© ì˜ˆì‹œ

#### ì˜ˆì‹œ 1: ì˜¤ë¥¸ìª½ 70% ë¼ì´ì € ë‹¹ê¹€
```
ì…ë ¥:
- leftPull = 0, rightPull = 0.7
- turnInput = 0.7

Yaw ê³„ì‚° (í•˜ë“œì›¨ì–´ ìš°ì„  ëª¨ë“œ):
- ëª©í‘œ íšŒì „ì†ë„ = 0.7 Ã— 4 rad/s = 2.8 rad/s (ì•½ 160Â°/s)
- í”„ë ˆì„ë‹¹ íšŒì „ = 160Â°/s Ã— 0.02s = 3.2Â° (50Hz ê¸°ì¤€)
- targetYaw += 3.2Â° (ëˆ„ì )

Roll ê³„ì‚°:
- targetRoll = 0.7 Ã— 20Â° = 14Â° (ì¦‰ì‹œ ì ìš©)

ì†ë„ ì˜í–¥:
- ë¸Œë ˆì´í¬ íš¨ê³¼ = 0% (í•œìª½ë§Œ ë‹¹ê¹€)
- ì „ì§„ ì†ë„ ìœ ì§€ = 12 m/s
```

#### ì˜ˆì‹œ 2: ì–‘ìª½ 50% ë™ì‹œ ë‹¹ê¹€ (ë¸Œë ˆì´í¬)
```
ì…ë ¥:
- leftPull = 0.5, rightPull = 0.5
- turnInput = 0

Yaw ê³„ì‚°:
- ëª©í‘œ íšŒì „ì†ë„ = 0 rad/s (ì§ì§„)
- Yaw í† í¬ = 0 NÂ·m

ë¸Œë ˆì´í¬ íš¨ê³¼:
- brakeInputDiffer = 1 - 0 = 1
- brakeInputMultiplier = 1 Ã— 0.5 Ã— 0.5 = 0.25
- brakeMultiplier = 1 - 0.25 = 0.75
- ì „ì§„ ì†ë„ = 12 Ã— 0.75 = 9 m/s (25% ê°ì†)
```

### 7. í•˜ë“œì›¨ì–´ ì „ì†¡ ë°ì´í„° êµ¬ì„± (í•˜ë“œì›¨ì–´ ìš°ì„  ëª¨ë“œ)

```csharp
// í•˜ë“œì›¨ì–´ ìš°ì„  ëª¨ë“œ: ëª©í‘œ ìœ„ì¹˜ë¥¼ ê³„ì‚°í•˜ì—¬ ì „ì†¡
private void CalculateAndSendTargetRotation()
{
    if (aresService == null || !aresService.IsConnected) return;
    
    // ë¼ì´ì € ì…ë ¥ìœ¼ë¡œ ëª©í‘œ ê°ë„ ê³„ì‚°
    float turnInput = rightPull - leftPull;
    
    // Yaw: ëˆ„ì  íšŒì „ (ì—°ì†ì )
    float yawDelta = turnInput * maxYawSpeed * Time.fixedDeltaTime * Mathf.Rad2Deg;  // rad/s â†’ deg/s
    targetYaw += yawDelta;
    targetYaw = Mathf.Repeat(targetYaw, 360f);  // 0~360 ë²”ìœ„ ìœ ì§€
    
    // Roll: ì¦‰ê° ë°˜ì‘ (ë¹„ëˆ„ì )
    targetRoll = turnInput * maxRoll;  // -20Â° ~ +20Â°
    targetRoll = Mathf.Clamp(targetRoll, -maxRoll, maxRoll);
    
    var motionData = new AresMotionData
    {
        // ëª©í‘œ ìœ„ì¹˜ ì „ì†¡ (í˜„ì¬ ìœ„ì¹˜ê°€ ì•„ë‹˜!)
        YawAngle = targetYaw,
        RollAngle = targetRoll,
        
        // ë¼ì´ì € ì…ë ¥ê°’
        LeftRiser = leftPull,
        RightRiser = rightPull,
        
        // ì´ë²¤íŠ¸ ìƒíƒœ
        Event = currentEvent
    };
    
    aresService.SendMotionData(motionData);
    
    if (debugMode)
    {
        Debug.Log($"[Target] Yaw: {targetYaw:F1}Â°, Roll: {targetRoll:F1}Â°");
    }
}
```

### 7.1 í•˜ë“œì›¨ì–´ ìš°ì„  ëª¨ë“œ ì „ì²´ êµ¬í˜„ ì˜ˆì‹œ

```csharp
public class ParagliderController : MonoBehaviour
{
    [Header("Hardware Priority Mode")]
    [SerializeField] private bool hardwarePriorityMode = true;
    [SerializeField] private bool useSmoothInterpolation = true;
    [SerializeField] private float interpolationSpeed = 10f;
    
    private float targetYaw = 0f;
    private float targetRoll = 0f;
    private float lastHardwareUpdateTime;
    
    void Start()
    {
        // í•˜ë“œì›¨ì–´ ì„œë¹„ìŠ¤ ì´ˆê¸°í™”
        if (aresService != null)
        {
            aresService.OnFeedbackReceived += HandleAresFeedback;
        }
        
        // ì´ˆê¸° Yaw ì„¤ì •
        targetYaw = transform.eulerAngles.y;
    }
    
    void FixedUpdate()
    {
        if (!isJumpStart) return;
        
        if (hardwarePriorityMode && aresService?.IsConnected == true)
        {
            // í•˜ë“œì›¨ì–´ ìš°ì„  ëª¨ë“œ
            HardwarePriorityUpdate();
        }
        else
        {
            // í´ë°±: Unity ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜
            UnityPhysicsUpdate();
        }
    }
    
    private void HardwarePriorityUpdate()
    {
        // 1. ëª©í‘œ ìœ„ì¹˜ ê³„ì‚° ë° ì „ì†¡
        CalculateAndSendTargetRotation();
        
        // 2. ì†ë„ ì œì–´ (ì „ì§„/í•˜ê°•)ëŠ” Unityì—ì„œ ìœ ì§€
        if (_isPara)
        {
            RiserDamping();
            RegulateForwardSpeed();
            RegulateSinkRate();
        }
        
        // 3. íšŒì „ì€ í•˜ë“œì›¨ì–´ í”¼ë“œë°±ì„ ê¸°ë‹¤ë¦¼
        // Transform ì—…ë°ì´íŠ¸ëŠ” HandleAresFeedbackì—ì„œ ì²˜ë¦¬
    }
    
    private void HandleAresFeedback(AresFeedbackData feedback)
    {
        // ë¼ì´ì € ì…ë ¥ ì—…ë°ì´íŠ¸
        UpdateRiserInputs(feedback);
        
        // í•˜ë“œì›¨ì–´ ìš°ì„  ëª¨ë“œ: Transform ì—…ë°ì´íŠ¸
        if (hardwarePriorityMode && _isPara)
        {
            UpdateTransformFromHardware(feedback);
        }
        
        lastHardwareUpdateTime = Time.time;
    }
    
    private void UpdateTransformFromHardware(AresFeedbackData feedback)
    {
        float newYaw = feedback.YawPosition;
        float newRoll = feedback.RollPosition;
        
        if (useSmoothInterpolation)
        {
            // ë¶€ë“œëŸ¬ìš´ ë³´ê°„
            float currentYaw = transform.eulerAngles.y;
            float currentRoll = transform.eulerAngles.z;
            
            newYaw = Mathf.LerpAngle(currentYaw, newYaw, 
                                        interpolationSpeed * Time.deltaTime);
            newRoll = Mathf.LerpAngle(currentRoll, newRoll, 
                                         interpolationSpeed * Time.deltaTime);
        }
        
        // Transform ì—…ë°ì´íŠ¸
        transform.rotation = Quaternion.Euler(
            transform.eulerAngles.x,
            newYaw,
            newRoll
        );
    }
}
```

### 8. ë¬¼ë¦¬ íŒŒë¼ë¯¸í„° íŠœë‹ ê°€ì´ë“œ

| íŒŒë¼ë¯¸í„° | ê¸°ë³¸ê°’ | ë²”ìœ„ | íš¨ê³¼ |
|---------|--------|------|------|
| maxYawSpeed | 4 rad/s | 2-6 | ìµœëŒ€ íšŒì „ ì†ë„ |
| yawControlStrength | 5 | 3-10 | íšŒì „ ë°˜ì‘ì„± (ë†’ì„ìˆ˜ë¡ ë¹ ë¥¸ ë°˜ì‘) |
| yawDamping | 3 | 1-5 | íšŒì „ ê°ì‡  (ë†’ì„ìˆ˜ë¡ ë¶€ë“œëŸ¬ì›€) |
| maxRoll | 20Â° | 10-30 | ìµœëŒ€ ê¸°ìš¸ê¸° ê°ë„ |
| maxPitch | 10Â° | 5-15 | ìµœëŒ€ í”¼ì¹˜ ê°ë„ |
| selfLevelStrength | 5 | 3-10 | ìë™ ìˆ˜í‰ ë³µì› ê°•ë„ |
| selfLevelDamping | 5 | 3-10 | ë³µì› ê°ì‡  (ì§„ë™ ë°©ì§€) |

### 9. ë””ë²„ê¹… ë° ëª¨ë‹ˆí„°ë§

```csharp
void OnGUI()
{
    // ì‹¤ì‹œê°„ ìƒíƒœ í‘œì‹œ
    if (hardwarePriorityMode)
    {
        GUI.Label(new Rect(10, 10, 300, 25), 
            $"Mode: Hardware Priority");
        GUI.Label(new Rect(10, 35, 300, 25), 
            $"Target Yaw: {targetYaw:F1}Â°");
        GUI.Label(new Rect(10, 60, 300, 25), 
            $"Target Roll: {targetRoll:F1}Â°");
        GUI.Label(new Rect(10, 85, 300, 25), 
            $"Actual Yaw: {transform.eulerAngles.y:F1}Â°");
        GUI.Label(new Rect(10, 110, 300, 25), 
            $"Actual Roll: {transform.eulerAngles.z:F1}Â°");
    }
    else
    {
        GUI.Label(new Rect(10, 10, 300, 25), 
            $"Mode: Unity Physics");
        GUI.Label(new Rect(10, 35, 300, 25), 
            $"Yaw Speed: {rb.angularVelocity.y * Mathf.Rad2Deg:F1}Â°/s");
        GUI.Label(new Rect(10, 60, 300, 25), 
            $"Roll Angle: {transform.eulerAngles.z:F1}Â°");
    }
    
    GUI.Label(new Rect(10, 135, 300, 25), 
        $"Forward Speed: {Vector3.Dot(rb.linearVelocity, transform.forward):F1} m/s");
    GUI.Label(new Rect(10, 160, 300, 25), 
        $"Brake Effect: {(1-brakeMultiplier)*100:F0}%");
}
```

---

## 4. ê²Œì„ ë¡œì§ í†µí•©

### 4.1 ParagliderController í†µí•©

```csharp
public class ParagliderController : MonoBehaviour
{
    [Header("ARES Hardware Integration")]
    [SerializeField] private AresHardwareService aresService;
    
    private bool isJumpStart = false;
    private bool _isPara = false;
    private float initialYaw;
    
    void Start()
    {
        // ARES ì„œë¹„ìŠ¤ ì´ˆê¸°í™”
        if (aresService == null)
        {
            aresService = GetComponent<AresHardwareService>();
        }
        
        // ì´ë²¤íŠ¸ êµ¬ë…
        if (aresService != null)
        {
            aresService.OnFeedbackReceived += HandleAresFeedback;
            aresService.OnConnectionLost += HandleConnectionLost;
        }
    }
    
    void FixedUpdate()
    {
        if (!isJumpStart) return;
        
        if (hardwarePriorityMode && aresService?.IsConnected == true)
        {
            // í•˜ë“œì›¨ì–´ ìš°ì„  ëª¨ë“œ
            CalculateAndSendTargetRotation();
            
            if (_isPara)
            {
                RegulateForwardSpeed();
                RegulateSinkRate();
            }
        }
        else
        {
            // Unity ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œ (í´ë°±)
            if (_isPara)
            {
                ApplyTurning();
                RegulateForwardSpeed();
                RegulateSinkRate();
            }
        }
    }
}
```

### 4.2 ë‚™í•˜ ì‹œí€€ìŠ¤ êµ¬í˜„

```csharp
// ë‚™í•˜ ì‹œì‘
public void JumpStart()
{
    isJumpStart = true;
    initialYaw = transform.eulerAngles.y;
    
    // ììœ ë‚™í•˜ ì´ë²¤íŠ¸ ì „ì†¡
    if (jumpType != JumpType.STANDARD)
    {
        aresService?.SetEvent(AresEvent.FreeFall);
        Debug.Log("[ë‚™í•˜] FreeFall ì´ë²¤íŠ¸ ì „ì†¡");
    }
    
    // ë¬¼ë¦¬ ì‹œì‘
    rb.useGravity = true;
}

// ë‚™í•˜ì‚° ì „ê°œ
public void ParaDeploy()
{
    _isPara = true;
    
    // ì†ë„ íŒŒë¼ë¯¸í„° ë³€ê²½
    targetForwardSpeed = 12f;  // 12 m/s
    targetSinkSpeed = 5f;       // 5 m/s
    
    // ì „ê°œ ì´ë²¤íŠ¸ ì „ì†¡
    aresService?.SetEvent(AresEvent.Deploy);
    Debug.Log("[ë‚™í•˜ì‚°] Deploy ì´ë²¤íŠ¸ ì „ì†¡");
    
    col.enabled = true;
}

// ì°©ë¥™
public void OnLanding()
{
    aresService?.SetEvent(AresEvent.Landing);
    Debug.Log("[ì°©ë¥™] Landing ì´ë²¤íŠ¸ ì „ì†¡");
}
```

---

## 5. ì–‘ë°©í–¥ ë™ê¸°í™”

### 5.1 í•˜ë“œì›¨ì–´ í”¼ë“œë°± ì²˜ë¦¬

```csharp
private void HandleAresFeedback(AresFeedbackData feedback)
{
    // 1. ë¼ì´ì € ì…ë ¥ ì²˜ë¦¬
    if (feedback.LeftRiserLength >= 20f)
    {
        leftPull = feedback.LeftRiserLength / 100f;
        isInputRiserL = true;
    }
    else
    {
        leftPull = 0f;
        isInputRiserL = false;
    }
    
    if (feedback.RightRiserLength >= 20f)
    {
        rightPull = feedback.RightRiserLength / 100f;
        isInputRiserR = true;
    }
    else
    {
        rightPull = 0f;
        isInputRiserR = false;
    }
    
    // 2. ìœ„ì¹˜ ë™ê¸°í™”
    if (_isPara && (isInputRiserL || isInputRiserR))
    {
        ProcessPositionSync(feedback);
    }
}
```

### 5.2 ìœ„ì¹˜ ë™ê¸°í™” ë¡œì§

```csharp
private void ProcessPositionSync(AresFeedbackData feedback)
{
    // Yaw ë™ê¸°í™”
    float currentYaw = transform.eulerAngles.y;
    float targetYaw = feedback.YawPosition;
    float yawDiff = Mathf.Abs(Mathf.DeltaAngle(currentYaw, targetYaw));
    
    if (yawDiff > yawSyncThreshold)
    {
        Debug.Log($"[ë™ê¸°í™”] Yaw ì°¨ì´: {yawDiff:F1}Â° - ë³´ì • ì‹œì‘");
        
        // ë¶€ë“œëŸ¬ìš´ ë³´ê°„
        float newYaw = Mathf.LerpAngle(
            currentYaw, 
            targetYaw, 
            yawSyncSpeed * Time.fixedDeltaTime
        );
        
        transform.rotation = Quaternion.Euler(
            transform.eulerAngles.x,
            newYaw,
            transform.eulerAngles.z
        );
    }
    
    // Roll ë™ê¸°í™” (Ver 0205 ì´í›„)
    float currentRoll = transform.eulerAngles.z;
    float targetRoll = feedback.RollPosition;
    float rollDiff = Mathf.Abs(Mathf.DeltaAngle(currentRoll, targetRoll));
    
    if (rollDiff > rollSyncThreshold)
    {
        Debug.Log($"[ë™ê¸°í™”] Roll ì°¨ì´: {rollDiff:F1}Â° - ë³´ì • ì‹œì‘");
        
        float newRoll = Mathf.LerpAngle(
            currentRoll,
            targetRoll,
            rollSyncSpeed * Time.fixedDeltaTime
        );
        
        transform.rotation = Quaternion.Euler(
            transform.eulerAngles.x,
            transform.eulerAngles.y,
            newRoll
        );
    }
}
```

---

## 6. ì´ë²¤íŠ¸ ì²˜ë¦¬

### 6.1 ì´ë²¤íŠ¸ ì •ì˜

```csharp
public enum AresEvent
{
    None = 0,          // ê¸°ë³¸ ìƒíƒœ
    FreeFall = 1,      // ììœ ë‚™í•˜ (Pitching + Heave UP)
    Deploy = 2,        // ë‚™í•˜ì‚° ì „ê°œ (Pitching DOWN)
    Malfunction = 3,   // ê³ ì¥ (Heave DOWN)
    Landing = 4,       // ì°©ë¥™ ì§ì „ (Roll ìœ ì§€ + Heave ì²œì²œíˆ DOWN)
    Landed = 5         // ì°©ë¥™ ì™„ë£Œ (Roll í•´ì œ + Heave ì²œì²œíˆ DOWN)
}
```

### 6.2 ì´ë²¤íŠ¸ë³„ í•˜ë“œì›¨ì–´ ë°˜ì‘

| ì´ë²¤íŠ¸ | Pitching | Heave | Roll | ì„¤ëª… |
|--------|----------|-------|------|------|
| FreeFall | ë¹ ë¥´ê²Œ UP | ë¹ ë¥´ê²Œ UP | - | ë‚™í•˜ ì‹œì‘ ì¶©ê²© |
| Deploy | ë¹ ë¥´ê²Œ DOWN | - | - | ì „ê°œ ì¶©ê²© |
| Malfunction | - | ë¹ ë¥´ê²Œ DOWN | - | ê¸‰ë‚™í•˜ |
| Landing | - | ì²œì²œíˆ DOWN | ìœ ì§€ | ì°©ë¥™ ì¤€ë¹„ |
| Landed | - | ì²œì²œíˆ DOWN | í•´ì œ | ì°©ë¥™ ì™„ë£Œ |

---

## 7. ì—ëŸ¬ ì²˜ë¦¬ ë° ë³µêµ¬

### 7.1 ì—°ê²° ì‹¤íŒ¨ ì²˜ë¦¬

```csharp
private void HandleConnectionLost()
{
    Debug.LogWarning("[ARES] í•˜ë“œì›¨ì–´ ì—°ê²° ëŠê¹€!");
    
    // 1. ìë™ ì¬ì—°ê²° ì‹œë„
    if (autoReconnect && reconnectAttempts < maxReconnectAttempts)
    {
        reconnectAttempts++;
        Debug.Log($"[ARES] ì¬ì—°ê²° ì‹œë„ {reconnectAttempts}/{maxReconnectAttempts}");
        
        if (Initialize())
        {
            reconnectAttempts = 0;
            OnConnectionRestored?.Invoke();
        }
    }
    
    // 2. VR ì»¨íŠ¸ë¡¤ëŸ¬ë¡œ í´ë°±
    else
    {
        Debug.Log("[ARES] VR ì»¨íŠ¸ë¡¤ ëª¨ë“œë¡œ ì „í™˜");
        useVRControllerFallback = true;
    }
}
```

### 7.2 ë°ì´í„° ê²€ì¦

```csharp
private bool ValidateFeedback(AresFeedbackData feedback)
{
    // ë²”ìœ„ ê²€ì¦
    if (feedback.YawPosition < 0 || feedback.YawPosition > 360)
    {
        Debug.LogWarning($"[ARES] ë¹„ì •ìƒ Yaw ê°’: {feedback.YawPosition}Â°");
        return false;
    }
    
    if (feedback.RollPosition < -180 || feedback.RollPosition > 180)
    {
        Debug.LogWarning($"[ARES] ë¹„ì •ìƒ Roll ê°’: {feedback.RollPosition}Â°");
        return false;
    }
    
    if (feedback.LeftRiserLength < 0 || feedback.LeftRiserLength > 100)
    {
        Debug.LogWarning($"[ARES] ë¹„ì •ìƒ ì™¼ìª½ ë¼ì´ì € ê°’: {feedback.LeftRiserLength}%");
        return false;
    }
    
    if (feedback.RightRiserLength < 0 || feedback.RightRiserLength > 100)
    {
        Debug.LogWarning($"[ARES] ë¹„ì •ìƒ ì˜¤ë¥¸ìª½ ë¼ì´ì € ê°’: {feedback.RightRiserLength}%");
        return false;
    }
    
    // ê¸‰ê²©í•œ ë³€í™” ê°ì§€
    float deltaYaw = Mathf.Abs(feedback.YawPosition - lastYawPosition);
    if (deltaYaw > 180f)
    {
        Debug.LogWarning($"[ARES] ê¸‰ê²©í•œ Yaw ë³€í™”: {deltaYaw}Â°");
        return false;
    }
    
    return true;
}
```

---

## 8. ìµœì í™” ë° ì„±ëŠ¥

### 8.1 ìŠ¤ë ˆë“œ ë¶„ë¦¬

| ìŠ¤ë ˆë“œ | ì£¼ê¸° | ë‹´ë‹¹ ì‘ì—… |
|--------|------|-----------|
| Main Thread | 60 FPS | Unity ë Œë”ë§, ë¬¼ë¦¬ |
| Communication Thread | 10 Hz | í•˜ë“œì›¨ì–´ í†µì‹  |
| Network Thread | 4 Hz | ë‹¤ì¤‘ ì‚¬ìš©ì ë™ê¸°í™” |

### 8.2 ë©”ëª¨ë¦¬ ìµœì í™”

```csharp
public class AresHardwareService : MonoBehaviour
{
    // ê°ì²´ ì¬ì‚¬ìš©ìœ¼ë¡œ GC ë°©ì§€
    private readonly ARES_PARASIM_MOTION_EX_DATA cachedMotionData = new();
    private readonly AresFeedbackData cachedFeedback = new();
    private readonly object dataLock = new();
    
    // StringBuilder ì¬ì‚¬ìš©
    private readonly StringBuilder debugLog = new(256);
}
```

### 8.3 ì¡°ê±´ë¶€ ì—…ë°ì´íŠ¸

```csharp
private bool HasSignificantChange(AresMotionData current, AresMotionData last)
{
    const float ANGLE_THRESHOLD = 1f;    // 1ë„
    const float RISER_THRESHOLD = 0.05f; // 5%
    
    if (Mathf.Abs(current.RollAngle - last.RollAngle) > ANGLE_THRESHOLD)
        return true;
        
    if (Mathf.Abs(current.YawAngle - last.YawAngle) > ANGLE_THRESHOLD)
        return true;
        
    if (Mathf.Abs(current.LeftRiser - last.LeftRiser) > RISER_THRESHOLD)
        return true;
        
    if (Mathf.Abs(current.RightRiser - last.RightRiser) > RISER_THRESHOLD)
        return true;
        
    if (current.Event != last.Event)
        return true;
        
    return false;
}
```

---

## 9. í…ŒìŠ¤íŠ¸ ë° ê²€ì¦

### 9.1 ì—°ê²° í…ŒìŠ¤íŠ¸

```csharp
[ContextMenu("Test Hardware Connection")]
private void TestConnection()
{
    Debug.Log("=== ARES í•˜ë“œì›¨ì–´ ì—°ê²° í…ŒìŠ¤íŠ¸ ===");
    
    // 1. ì´ˆê¸°í™” í…ŒìŠ¤íŠ¸
    if (Initialize())
    {
        Debug.Log("âœ… ì´ˆê¸°í™” ì„±ê³µ");
        
        // 2. ìƒíƒœ í™•ì¸
        bool isConnected = AresParachuteAPI.ARESParaSIM__StateCheck();
        Debug.Log($"âœ… ì—°ê²° ìƒíƒœ: {(isConnected ? "ì—°ê²°ë¨" : "ëŠê¹€")}");
        
        // 3. ë°ì´í„° ì†¡ìˆ˜ì‹  í…ŒìŠ¤íŠ¸
        var testData = new ARES_PARASIM_MOTION_EX_DATA();
        testData.Init();
        
        ARES_PARASIM_FEEDBACK_EX_DATA feedback;
        bool success = AresParachuteAPI.ARESParaSIM__MotionControlEx(
            ref testData, 
            out feedback
        );
        
        if (success)
        {
            Debug.Log("âœ… ë°ì´í„° ì†¡ìˆ˜ì‹  ì„±ê³µ");
            Debug.Log($"  - Roll Position: {feedback.RollPosition}");
            Debug.Log($"  - Yaw Position: {feedback.YawingPosition}");
            Debug.Log($"  - Left Riser: {feedback.LTRiserLineCurrentLength}%");
            Debug.Log($"  - Right Riser: {feedback.RTRiserLineCurrentLength}%");
        }
        else
        {
            Debug.LogError("âŒ ë°ì´í„° ì†¡ìˆ˜ì‹  ì‹¤íŒ¨");
        }
    }
    else
    {
        Debug.LogError("âŒ ì´ˆê¸°í™” ì‹¤íŒ¨");
    }
}
```

### 9.2 ì´ë²¤íŠ¸ í…ŒìŠ¤íŠ¸

```csharp
[ContextMenu("Test All Events")]
private IEnumerator TestAllEvents()
{
    Debug.Log("=== ì´ë²¤íŠ¸ í…ŒìŠ¤íŠ¸ ì‹œì‘ ===");
    
    // FreeFall
    SetEvent(AresEvent.FreeFall);
    Debug.Log("1. FreeFall ì´ë²¤íŠ¸ ì „ì†¡");
    yield return new WaitForSeconds(2f);
    
    // Deploy
    SetEvent(AresEvent.Deploy);
    Debug.Log("2. Deploy ì´ë²¤íŠ¸ ì „ì†¡");
    yield return new WaitForSeconds(2f);
    
    // Landing
    SetEvent(AresEvent.Landing);
    Debug.Log("3. Landing ì´ë²¤íŠ¸ ì „ì†¡");
    yield return new WaitForSeconds(2f);
    
    // Landed
    SetEvent(AresEvent.Landed);
    Debug.Log("4. Landed ì´ë²¤íŠ¸ ì „ì†¡");
    yield return new WaitForSeconds(2f);
    
    // Reset
    SetEvent(AresEvent.None);
    Debug.Log("5. ì´ë²¤íŠ¸ ë¦¬ì…‹");
    
    Debug.Log("=== ì´ë²¤íŠ¸ í…ŒìŠ¤íŠ¸ ì™„ë£Œ ===");
}
```

### 9.3 ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§

```csharp
public class PerformanceMonitor : MonoBehaviour
{
    public int TotalPacketsSent { get; private set; }
    public int TotalPacketsReceived { get; private set; }
    public float AverageLatency { get; private set; }
    public DateTime LastSuccessfulUpdate { get; private set; }
    
    void OnGUI()
    {
        GUI.Label(new Rect(10, 10, 300, 25), 
            $"íŒ¨í‚· ì†¡ì‹ : {TotalPacketsSent}");
        GUI.Label(new Rect(10, 35, 300, 25), 
            $"íŒ¨í‚· ìˆ˜ì‹ : {TotalPacketsReceived}");
        GUI.Label(new Rect(10, 60, 300, 25), 
            $"í‰ê·  ì§€ì—°: {AverageLatency:F1}ms");
        GUI.Label(new Rect(10, 85, 300, 25), 
            $"ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: {LastSuccessfulUpdate:HH:mm:ss}");
    }
}
```

---

## ğŸ“ ì²´í¬ë¦¬ìŠ¤íŠ¸

### ì´ˆê¸° ì„¤ì •
- [ ] DLL íŒŒì¼ Assets/Plugins í´ë”ì— ë³µì‚¬
- [ ] Visual C++ ì¬ë°°í¬ íŒ¨í‚¤ì§€ ì„¤ì¹˜
- [ ] COM í¬íŠ¸ ë²ˆí˜¸ í™•ì¸ ë° ì„¤ì •
- [ ] Unity í”„ë¡œì íŠ¸ ì„¤ì • (Android, Meta XR)

### êµ¬í˜„ í™•ì¸
- [ ] AresHardwareService ì»´í¬ë„ŒíŠ¸ ì¶”ê°€
- [ ] ParagliderController ì—°ë™
- [ ] ë°ì´í„° ë³€í™˜ ë¡œì§ êµ¬í˜„
- [ ] ì´ë²¤íŠ¸ ì²˜ë¦¬ êµ¬í˜„
- [ ] ì—ëŸ¬ ì²˜ë¦¬ êµ¬í˜„

### í…ŒìŠ¤íŠ¸
- [ ] í•˜ë“œì›¨ì–´ ì—°ê²° í…ŒìŠ¤íŠ¸
- [ ] ë°ì´í„° ì†¡ìˆ˜ì‹  í…ŒìŠ¤íŠ¸
- [ ] ì´ë²¤íŠ¸ ë°˜ì‘ í…ŒìŠ¤íŠ¸
- [ ] ì–‘ë°©í–¥ ë™ê¸°í™” í…ŒìŠ¤íŠ¸
- [ ] ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§

### ìµœì¢… ê²€ì¦
- [ ] 10Hz í†µì‹  ì£¼ê¸° í™•ì¸
- [ ] ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ì²´í¬
- [ ] ì¥ì‹œê°„ ì•ˆì •ì„± í…ŒìŠ¤íŠ¸
- [ ] VR ì»¨íŠ¸ë¡¤ëŸ¬ í´ë°± ë™ì‘ í™•ì¸

---

## ğŸ”§ íŠ¸ëŸ¬ë¸”ìŠˆíŒ…

### ë¬¸ì œ: DLLì„ ì°¾ì„ ìˆ˜ ì—†ìŒ
**í•´ê²°ë°©ë²•:**
1. Visual C++ 2015-2022 ì¬ë°°í¬ ê°€ëŠ¥ íŒ¨í‚¤ì§€ ì„¤ì¹˜
2. DLL íŒŒì¼ì„ Assets/Plugins í´ë”ì— ë³µì‚¬
3. Unity Editor ì¬ì‹œì‘

### ë¬¸ì œ: COM í¬íŠ¸ ì—°ê²° ì‹¤íŒ¨
**í•´ê²°ë°©ë²•:**
1. ì¥ì¹˜ ê´€ë¦¬ìì—ì„œ COM í¬íŠ¸ ë²ˆí˜¸ í™•ì¸
2. ë‹¤ë¥¸ í”„ë¡œê·¸ë¨ì´ í¬íŠ¸ ì‚¬ìš© ì¤‘ì¸ì§€ í™•ì¸
3. USB ì¼€ì´ë¸” ì—°ê²° ìƒíƒœ í™•ì¸

### ë¬¸ì œ: ë°ì´í„° ë™ê¸°í™” ì§€ì—°
**í•´ê²°ë°©ë²•:**
1. í†µì‹  ì£¼ê¸° í™•ì¸ (10Hz)
2. Thread.Sleep(20) ê°’ ì¡°ì •
3. ë„¤íŠ¸ì›Œí¬ ë¶€í•˜ í™•ì¸

### ë¬¸ì œ: ê¸‰ê²©í•œ ì›€ì§ì„
**í•´ê²°ë°©ë²•:**
1. ë³´ê°„ ì†ë„ (SyncSpeed) ê°’ ì¡°ì •
2. ë°ì´í„° ê²€ì¦ ì„ê³„ê°’ í™•ì¸
3. í•˜ë“œì›¨ì–´ ìº˜ë¦¬ë¸Œë ˆì´ì…˜

---

## ğŸ“š ì°¸ê³  ìë£Œ

- ARES_Parachute_Simulator_SDK_API_Ver0205.pdf
- Unity 6.1 Documentation
- Meta XR SDK Documentation
- [í”„ë¡œì íŠ¸ GitHub ì €ì¥ì†Œ]

---

*ìµœì¢… ì—…ë°ì´íŠ¸: 2025ë…„ 9ì›”*
*ì‘ì„±ì: ARES ParaSim VR ê°œë°œíŒ€*